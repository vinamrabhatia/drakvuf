//basic drakvuf pages!

Drakvuf main structure has the following information:

    drakvuf_c(const char* domain,
              const char* rekall_profile,
              const char* rekall_wow_profile,  //check whats this
              output_format_t output,
              bool verbose,
              bool leave_paused,
              bool libvmi_conf);
    }

//Injector command in the drakvuf code?
drakvuf->inject_cmd

main.cpp :
Basically just selects all the options!

drakvuf.cpp:
Declares a class, and implements object function; these are implemented in libdrakvuf.h

Inside libdrakvuf folder:

drakvuf.c: implements major of the class methods of drakvuf.cc outside.

private.h has the main structures

struct drakvuf
{
    char* dom_name;
    domid_t domID;
    char* rekall_profile;
    json_object* rekall_profile_json;
    os_t os;
    char* rekall_wow_profile;
    json_object* rekall_wow_profile_json;

    xen_interface_t* xen;
    os_interface_t osi;
    uint16_t altp2m_idx, altp2m_idr;

    xen_pfn_t zero_page_gfn;

    // VMI
    unsigned long flush_counter;
    GMutex vmi_lock;
    vmi_instance_t vmi;

    vmi_event_t cr3_event;
    vmi_event_t interrupt_event;
    vmi_event_t mem_event;
    vmi_event_t debug_event;
    vmi_event_t cpuid_event;
    vmi_event_t* step_event[16];
    drakvuf_trap_t guard0;

    size_t* offsets;
    size_t* sizes;

    size_t* wow_offsets;

    // Processing trap removals in trap callbacks
    // is problematic so we save all such requests
    // in a list to be processed after all callbacks
    // are finished.
    bool in_callback;
    GHashTable* remove_traps;

    int interrupted;
    page_mode_t pm;
    unsigned int vcpus;
    uint64_t init_memsize;
    xen_pfn_t max_gpfn;
    addr_t kernbase;
    addr_t kdtb;

    int address_width;

    GHashTable* remapped_gfns; // Key: gfn
    // val: remapped gfn

    GHashTable* breakpoint_lookup_pa;   // key: PA of trap
    // val: struct breakpoint
    GHashTable* breakpoint_lookup_gfn;  // key: gfn (size uint64_t)
    // val: GSList of addr_t* for trap locations
    GHashTable* breakpoint_lookup_trap; // key: trap pointer
    // val: struct breakpoint

    GHashTable* memaccess_lookup_gfn;  // key: gfn of trap
    // val: struct memaccess
    GHashTable* memaccess_lookup_trap; // key: trap pointer
    // val: struct memaccess

    GSList* cr0, *cr3, *cr4, *debug, *cpuid;

    GSList* event_fd_info;     // the list of registered event FDs
    struct pollfd* event_fds;  // auto-generated pollfd for poll()
    int event_fd_cnt;          // auto-generated for poll()
    fd_info_t fd_info_lookup;  // auto-generated for fast drakvuf_loop lookups
};

struct fd_info
{
    int fd;
    event_cb_t event_cb;
    void* data;
};

struct breakpoint
{
    addr_t pa;
    drakvuf_trap_t guard, guard2;
    bool doubletrap;
};
struct memaccess
{
    addr_t gfn;
    bool guard2;
    vmi_mem_access_t access;
};

struct wrapper
{
    trap_type_t type;
    drakvuf_t drakvuf;
    GSList* traps; /* List of DRAKVUF traps registered for this event */
    union
    {
        struct memaccess memaccess;
        struct breakpoint breakpoint;
    };
};

struct free_trap_wrapper
{
    unsigned int counter;
    drakvuf_trap_t* trap;
    drakvuf_trap_free_t free_routine;
};

struct remapped_gfn
{
    xen_pfn_t o;
    xen_pfn_t r;
    bool active;
};

typedef struct process_data_priv
{
    char* name;   /* Process name */
    vmi_pid_t pid ;     /* Process pid */
    vmi_pid_t ppid ;    /* Process parent pid */
    addr_t base_addr ;  /* Process base address */
    int64_t userid ;    /* Process SessionID/UID */
} proc_data_priv_t ;

struct memcb_pass
{
    drakvuf_t drakvuf;
    uint64_t gfn;
    addr_t pa;
    proc_data_priv_t proc_data ;
    struct remapped_gfn* remapped_gfn;
    vmi_mem_access_t access;
    GSList* traps;
};

//Lots of structures to look for!


//GSList is integer values or pointers to data.

inject_traps
event_response

os.c : defines private.h and takes in the fucnctions common for both windows and linux.
has os_interface_t which declares function pointers.

linux.c : Takes os.c, declares all the os functions specific to linus, also includes other linux files(linux-offsets-map.h and linux-offsets)

rekall-profiles.c : Looks up at the rekall profiles json and gives us back the os, symbols details! 

vmi.c : Mainly interacts with LIBVMI, used for inserting traps and managing control events.

win.c : handles all the win os based functions, uses win-offset-maps, win-wow-offset maps.
win-processes.c: handles all the windows process related functions and includes all the above files.

Other helper windows files:
win-files: get-filename-from-handle
win-exports: search for the given module+symbol in the given module list
win-error-codes: //
win-handles: 
win-registry: 
win-symbols: looks up in rekall for the symbols.


------------

injector.c outside takes all the options

Inside libinjector folder:

libinjector_stack.c has helper functions:
setup_stack is the function which uses all the other functions of the library. 
which calls setup_stack_64/32: It puts all the arguments on the stack, saves the return address, grows the stack in size and writes this into the memory of the guest with the help of libVMI, 

libinjector.c : major functions:

has important structures:

struct injector:
for inputs, internals, creating process, shellcode execution, results;

structures for starting 32-bit-window, 64-bit-window, 32 bit process info, 64 bit process info;

setup_create_process_stack calls the libinjector_stack functions and other functions like setup_resume_thread_stack, setup_shell_execute_stack etc.

Steps involved in Injector:

1. Find the process in the OS with the process ID.
2. Get the offsets from the Rekall profile
3. If the injection method is createproc:
4. Check the current process if it contains the library and the loaded function: 'ResumeThread'/'CreateProcessW'
5. Add a trap to the process for CR3 register. (wait_for_target_process_cb) and (wait_for_crash_of_target_proces)
	//Following the path of execution for 64 bit.
	//The wait_for_target_process_cb traps CR3 register events, and the process id and/or thread-id matches, 
	//This process is in kernel-mode, so the trap is set as soon as it reaches user mode. 
	//For 64 bit, setup_int3_trap is called which sets a trap with the callback fucntion set as injector_int3_cb.
	//(!injector->is32bit && !injector->hijacked && injector->status == STATUS_NULL) //registers are copied and 
6. DRAKVUF loops till it interruped, after which it frees the memory!

Syscalls require the context of user space program. 

//Only focusing on CreateProcessA for 64 bit first!

1. Initialise Injector


2. injector->exec_func = get_function_va(drakvuf, eprocess_base, "kernel32.dll", "CreateProcessW", injector->global_search);

Get the virtual address of the function that we wish to call!
-----Now, do we have to search for this function in the symbols or do we try to find it loaded in a process?
-----Search if this function is even present in the symbols?! --So getting the address is this way: get_function_va
[[[-----When you search for your function, you search for it in the module as well as in the symbols----- ]]]


//Understand access_context as well. 

typedef struct {
    translation_mechanism_t translate_mechanism;

    addr_t addr;      /**< specify iff using VMI_TM_NONE, VMI_TM_PROCESS_DTB or VMI_TM_PROCESS_PID */
    const char ksym; /*< specify iff using VMI_TM_KERNEL_SYMBOL */
    addr_t dtb;       /**< specify iff using VMI_TM_PROCESS_DTB */
    vmi_pid_t pid;    /**< specify iff using VMI_TM_PROCESS_PID */
} access_context_t;

typedef enum translation_mechanism {
    VMI_TM_INVALID,         /**< Invalid translation mechanism */
    VMI_TM_NONE,            /**< No translation is required, address is physical address */
    VMI_TM_PROCESS_DTB,     /**< Translate addr via specified directory table base. */
    VMI_TM_PROCESS_PID,     /**< Translate addr by finding process first to use its DTB. */
    VMI_TM_KERNEL_SYMBOL    /**< Find virtual address of kernel symbol and translate it via kernel DTB. */
} translation_mechanism_t;


If function is not present in this module, check other modules loaded in the process.
//Check if you want more details of searching into modules!

3. Callback functions are wait_for_target_process_cb and wait_for_crash_of_target_process(just report ) //We are waiting for it to switch to the uprocess where we want to inject, we dont need to do this.
//We already have our callback function setup. 

//Here, injector waits for the process to reach user-mode since CreateProcessA is a user-level function. We dont need to do that
//  * For 64-bit Windows we use the trapframe approach, where we read. * the saved RIP from the stack trap frame and breakpoint it. 
//  By reading the saved RIP and trapping there, we wait for the process to reach the user-mode, we move step-wise and break out trap there. 
//  Trapframe stores register set which was saved during exception have arised, so using trapframe we can return back and proceed execution (when exception or irq will be handled)

So, in wait_for_process_cb, we go to setup_int3_trap where we go to callback function injector_int3_cb. 

This callback function performs various checks and proceeds when we hit the RIP from the trapframe.

-> Save all your registers here and call [setup_create_process_stack(injector, info); injector->target_rsp = info->regs->rsp;]

-> setup_create_process_stack: 

//We have arguments of the types on stack.
struct argument
{
    uint32_t type;
    uint32_t size;
    uint64_t data_on_stack;
    void* data;
};

You have to initialise int argument, unicode argument and structure arguments(take care to do this! and give startup information and process information!
----Do we have to give startup information and process information for the kernel functions too? (--CHECK--)
----Check why we have to use the following function: [convert_utf8_to_utf16 (--CHECK--)]

From here, we call the setup_stack function; get the windows architecture and go to setup_stack_64. 
----We have noted down rsp's address.  
Take care of alignment in case of string and struct arguments.  Make stack 16 byte aligned too. 
Copy the first 4 arguments into registers and others into memory, allocate homing space, ---save the return address on stack--- and grow the stack. 
injector->target_rsp = info->regs->rsp;!
info->regs->rip = injector->exec_func;

-> After calling the function and setting up the stack; [hijack the process and injector->status = STATUS_CREATE_OK;] Drakvuf loop keeps on running. 

-> The second part is being done for return values majorly! When we have the return, we have the same breakpoint since the return address was the same value. 

// injector->rc = info->regs->rax;

So to set up the stack, we need the following information:

-> Save all your registers here and call [setup_create_process_stack(injector, info); injector->target_rsp = info->regs->rsp;]
-> setup_create_process_stack: 